# ATON Web Dev Test Task 1

Тестовое задание №1 для стажировки АТОН на позицию веб-разработчика.

## Описание

### Комментарии

По требованиям к странице:

- Заголовок добавлен в виде надписи в верхней части страницы, также страница содержит заголовок в виде поля _title_
- В таблице отображаются следующие столбцы: номер записи, идентификатор, название, цена, когда создан
- Для доступности страницы по URL приложение было развернуто в контейнере Docker на домашнем сервере, для публичного
  доступа был использован KeenDNS

По требованиям к базе данных:

- В таблице _products_ также использованы столбцы для индексации и установки метки времени создания записи о продукте
- Для доступа к БД в целях удобства и декорирования построения запросов используется библиотека Medoo вместо
  использования PDO напрямую

По требованиям к коду:

- В качестве основных средств документации используются комментарии и текущий файл README
- При желании можно применить автоматизированную генерацию документации на основе комментариев

По требованиям к оформлению html/css:

- Указано, что названия товаров и их цены должны отличаться по цвету, поэтому, чтобы не делать таблицу слишком пестрой,
  я выделил цену отличающимся от значений других столбцов цветом
- Указано, что страница должна быть "резиновой", поэтому я применил разные View Points и Layout из Bootstrap. Однако в
  связи с тем, что в описании задания фигурировала таблица, а не табличное представление, я применил именно её (HTML тег
  table). Но по идее такой элемент очень плохо совместим с responsive design, потому что его представлением в разных
  размерах сложно управлять и правильнее было бы применить кастомную совокупность блоков с flex`ом

### Несколько слов об интерфейсе

Страница поделена на горизонтальные зоны:

1. Заголовок страницы
2. Поля глобального поиска: строка запроса поиска по имени; выбор сортировки по цене; количество продуктов, отображаемых
   на странице; а также кнопка для выполнения поиска
3. Область вспомогательных инструментов таблицы продуктов: строка локального (без обновления страницы, по загруженным
   записям) поиска по названию продукта (товара), счетчики количества отображаемых и найденных записей
4. Таблица с товарами, в заголовке которой можно управлять сортировкой по цене среди загруженных товаров
5. Строки с записями о товарах
6. Пагинация в случае, если общее количество найденных продуктов больше, чем отображаемое на странице
7. Блок со ссылкой на исходный код на GitHub

### Логика работы и технические детали

Хотя приложение подразумевает одну страницу, оно построено по принципу единой точки входа (Entry Point).
То есть сервер перенаправляет все запросы к "страницам" (за исключением запросов к существующим файлам)
на один скрипт, который уже определяет, как их обрабатывать.

Таким образом, Nginx (или другой веб-сервер) перенаправляет запрос на _public/index.php_, там посредством PHP
выполняется приложение.
В начале загружаются переменные среды, создается экземпляр конфигурации, создается подключение к БД.
В нашем случай мы имеем один EndPoint, а именно поиск продуктов.
Поиск продуктов обрабатывается специальным классом, который использует вспомогательные Use Cases для
определения параметров запроса и их валидации.

Получив корректный массив параметров поиска продуктов, происходит обращение к БД в два этапа.
Сначала определяется общее количество подходящих записей.
Потом выполняется выбор части записей в соответствии с параметрами поиска.

В этом моменте стоит упомянуть, что если имеется высокая нагрузка, то можно добавить
кеширование запросов к БД. А также в случае большого количества записей имеет смысл подсчитывать количества продуктов
не на прямую, а с помощью кеширования или более сложного механизма.

Затем формируется массив результата поиска, который передается на специальный класс, отвечающий за отображение
страницы с продуктами. Там загружается шаблон страницы сайта с соответствующим компонентом показа продуктов.

Данные о загруженных продуктах отображаются на странице не напрямую, они инициализируются в качестве JavaScript объекта,
за обработку которого отвечает клиентское JavaScript приложение.

Стоит отметить, что в приложении происходит следующая обработка ошибок: исключения делятся на управляемые -
экземпляры UniException из _mggflow/exception-manager_, и неуправляемые - возникновение которых не запланировано.
В первом случае информация об ошибке отображается на отдельной странице. А во втором случае возвращается ответ сервера с
кодом 500.

Клиентская часть построена по модульному принципу, в котором логика приложения разделена на Use Cases.
При этом приложение в целом объединено в бандл с помощью WebPack и минифицировано с помощью UglifyJS.
JavaScript приложение отвечает за отображение продуктов, их локальный поиск по названию, сортировку по цене,
работу пагинации, управление взаимодействием с сервером путем передачи параметров в строке запроса URI (GET-параметры).

Для оформления страниц использовался CSS фреймворк Bootstrap 5.

## Демо

Демонстрация созданного приложения доступна по ссылке:
https://mggflow.in/t/atontesttask1

P.S.: ссылка не прямая, т.к. по техническим причинам реальное расположение приложения может меняться.

## Развертывание

### Docker

- Создайте пустую директорию для приложения

```
sudo mkdir ./task1
```

- Сделайте её владельцем текущего пользователя (user - имя вашего пользователя)

```
sudo chown user:user ./task1
```

- Скачайте исходный код приложения из GitHub

```
gh repo clone deusagnis/aton-web-dev-test-task-1 ./task1
```

- Для удобства можно перейти в эту директорию

```
cd ./task1
```

- Скорректируйте файл docker-compose в соответствии со своими нуждами
  (По умолчанию приложение использует порт 9100, также потребуется задать
  пароль для базы данных)
- Затем копируйте файл окружения и измените его в соответствии с вашими параметрами

```
cp ./.env.example ./.env
nano ./.env
```

P.S.: например, в docker-compose используется имя:"db" для контейнера с БД, оно будет являться хостом для подключения

- Теперь потребуется собрать Docker образ для приложения

```
docker-compose build
```

- Всё готово к запуску, можно запускать соответствующий скрипт

```
sh ./docker-first-launch.sh
```

- Чтобы остановить приложение, необходимо в соответствующей папке выполнить

```
docker-compose down
```

- Для последующих запусков будет достаточно

```
docker-compose up -d
```

Также может понадобиться открыть используемый приложением порт

```
sudo ufw allow 9100
```

### Локальное окружение

Логика развертывания в локальном окружении аналогична развертыванию
в Docker, однако менее автоматизирована.

Для запуска на локальном окружении потребуется настроить перенаправление всех
запросов в папку _public_, а в случае, если файл будет не обнаружен, то на
точку входа в приложение - файл _public/index.php_.

Пример конфигурации для сервера Nginx можно найти в папке _docker-compose/nginx_.

Требования:

- NodeJs >=16.\*.\*
- PHP >=7.4.*
- NPM >=8.11.*
- Composer >=2.\*.\*
- MySQL \ Maria DB

Остальные зависимости можно установить с помощью Composer

```
composer install
```

И NPM

```
npm install
```

Для сборки клиентского приложения на JS добавлена команда

```
npm run build
```

Также понадобится база данных, SQL запрос для создания можно посмотреть
в файле _docker-compose/maria-db/init.sql_.

Для создания необходимой таблицы добавлена команда

```
composer run-script migrate
```

Для наполнения таблицы тестовыми значениями добавлена команда

```
composer run-script seed
```

## Тесты

В качестве фреймворка для тестов используется PHPUnit, следовательно, для запуска тестов
должно быть доступно соответствующее окружение.
В случае запуска Docker, оно присутствует, но для запуска команд в контейнере их нужно снабжать
приставкой:

```
docker-compose exec app
```

Где app - название сервиса из docker-compose.yml.

Для запуска тестов можно выполнить команду Composer

```
composer run-script test
```